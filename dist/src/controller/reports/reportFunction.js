"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var oracleClient_1 = __importDefault(require("../../model/oracleClient"));
var Report = /** @class */ (function () {
    function Report() {
    }
    Report.prototype.mis = function (startingDate) {
        return __awaiter(this, void 0, void 0, function () {
            var sql, bindParams, payload;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sql = "SELECT REG.NAME AS \"AGENT\",A.OFF_ADDR AS \"ADDRESS\", REG.REG_DATE AS \"OPENDATE\",     PREVIOUS_BALANCE.TOTAL + 1 AS \"PREVIOUSNOOFACCOUNT\", CURRNET_BALANCE.TOTAL + 1 AS \"CURRENTNOOFACCOUNT\",\n           TANBIN.GETBALANCE (REG.MPHONE, TO_DATE(:startingDate, 'DD/MM/RRRR'))\n         + COALESCE (PREVIOUS_BALANCE.AMT, 0)\n             AS \"PREVIOUSBALANCE\",\n           TANBIN.GETBALANCE (REG.MPHONE, TO_DATE(:startingDate, 'DD/MM/RRRR'))\n         + COALESCE (CURRNET_BALANCE.AMT, 0)\n             AS \"CURRENTBALANCE\",\n         COALESCE (REMITTANCE_PREVIOUS_MONTH.TOTAL, 0)\n             AS \"PREVIOUSNOOFREMITTANCE\",\n         COALESCE (REMITTANCE_PREVIOUS_MONTH.AMT, 0)\n             AS \"PREVIOUSREMITTANCEAMOUNT\",\n         COALESCE (REMITTANCE_CURRENT_MONTH.TOTAL, 0)\n             AS \"CURRENTNOOFREMITTANCE\",\n         COALESCE (REMITTANCE_CURRENT_MONTH.AMT, 0)\n             AS \"CURRENTREMITTANCEAMOUNT\",\n         COALESCE (UP.TOTAL, 0)\n             AS \"PREVIOUSNOOFUTILITY\",\n         COALESCE (UP.AMT, 0)\n             AS \"PREVIOUSUTILITYAMOUNT\",\n         COALESCE (UC.TOTAL, 0)\n             AS \"CURRENTNOOFUTILITY\",\n         COALESCE (UC.AMT, 0)\n             AS \"CURRENTUTILITYAMOUNT\",\n         COALESCE (PRE_COM.COMMISSION, 0)\n             AS \"COMMISSIONPREVIOUSMONTH\",\n         COALESCE (COM.COMMISSION, 0)\n             AS \"COMMISSIONTHISMONTH\"\n    FROM AGENT_BANKING.REGINFO REG\n         JOIN AGENT_BANKING.AGENT_INFO A ON REG.DIST_CODE = A.MPHONE\n         -- Deposit Previous Month\n         JOIN\n         (  SELECT PMPHONE, COUNT (*) TOTAL, SUM (BALANCE) AMT\n              FROM (SELECT MPHONE,\n                           PMPHONE,\n                           TANBIN.FUNC_GET_ACC_BALANCE (\n                               MPHONE,\n                               ADD_MONTHS (\n                                   TRUNC (TO_DATE(:startingDate, 'DD/MM/RRRR'),\n                                          'MONTH'),\n                                   -1))    BALANCE\n                      FROM AGENT_BANKING.REGINFO R\n                           LEFT JOIN AGENT_BANKING.ACC_CLOSING C\n                               ON     R.MPHONE = C.AC_NO\n                                  AND C.STATUS = 'S'\n                                  AND TRUNC (C.CREATE_DATE) <=\n                                      ADD_MONTHS (\n                                          TRUNC (TO_DATE(:startingDate, 'DD/MM/RRRR'),\n                                                 'MONTH'),\n                                          -1)\n                     WHERE     TRUNC (REG_DATE) <=\n                               ADD_MONTHS (\n                                   TRUNC (TO_DATE(:startingDate, 'DD/MM/RRRR'),\n                                          'MONTH'),\n                                   -1)\n                           AND REG_STATUS <> 'R'\n                           AND CAT_ID <> 'D'\n                           AND C.AC_NO IS NULL) PC\n          GROUP BY PMPHONE) PREVIOUS_BALANCE\n             ON REG.MPHONE = PREVIOUS_BALANCE.PMPHONE\n         -- Deposit cURRENT Month\n         JOIN\n         (  SELECT PMPHONE, COUNT (*) AS TOTAL, SUM (BALANCE) AS AMT\n              FROM (SELECT MPHONE,\n                           PMPHONE,\n                           TANBIN.GETBALANCE (R.MPHONE,\n                                              TO_DATE(:startingDate, 'DD/MM/RRRR'))    AS BALANCE\n                      FROM AGENT_BANKING.REGINFO R\n                     WHERE     TRUNC (REG_DATE) <= TO_DATE ( :startingDate, 'DD/MM/RRRR')\n                           AND REG_STATUS <> 'R'\n                           AND CAT_ID <> 'REG'\n                           AND R.MPHONE NOT IN\n                                   (SELECT AC_NO\n                                      FROM AGENT_BANKING.ACC_CLOSING\n                                     WHERE     STATUS = 'S'\n                                           AND TRUNC (CREATE_DATE) <=\n                                               TO_DATE ( :startingDate, 'DD/MM/RRRR')))\n          GROUP BY PMPHONE) CURRNET_BALANCE\n             ON REG.MPHONE = CURRNET_BALANCE.PMPHONE\n         /* --------------------------\n\n                                Remittance\n\n                    ------------------------------ */\n         -- Remittance Previous Month\n         LEFT JOIN\n         (  SELECT REC_AGENT_ACC, COUNT (*) AS TOTAL, SUM (SEN_REM_AMT) AS AMT\n              FROM AGENT_BANKING.REMITTANCE_INFO R\n             WHERE     STATUS = 'A'\n                   AND TRUNC (ENTRY_DATE) BETWEEN TRUNC (\n                                                      ADD_MONTHS (\n                                                          TRUNC (\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1),\n                                                      'MM')\n                                              AND LAST_DAY (\n                                                      ADD_MONTHS (\n                                                          TRUNC (\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1))\n          GROUP BY REC_AGENT_ACC) REMITTANCE_PREVIOUS_MONTH\n             -- << REMITTANCE PREVIOUS\n             ON REG.MPHONE = REMITTANCE_PREVIOUS_MONTH.REC_AGENT_ACC\n         -- Remittance Current Month\n         LEFT JOIN\n         (  SELECT REC_AGENT_ACC, COUNT (*) AS TOTAL, SUM (SEN_REM_AMT) AS AMT\n              FROM AGENT_BANKING.REMITTANCE_INFO R\n             WHERE     STATUS = 'A'\n                   AND TRUNC (ENTRY_DATE) BETWEEN TRUNC (\n                                                      TO_DATE(:startingDate,\n                                                               'DD/MM/RRRR'),\n                                                      'YEAR')\n                                              AND TO_DATE(:startingDate, 'DD/MM/RRRR')\n          GROUP BY REC_AGENT_ACC) REMITTANCE_CURRENT_MONTH\n             -- << REMITTANCE CURRENT\n             ON REG.MPHONE = REMITTANCE_CURRENT_MONTH.REC_AGENT_ACC\n         /* --------------------------\n\n                                Utility\n\n                    ------------------------------ */\n         -- Utility Previous Month\n         LEFT JOIN\n         (  SELECT ENTRY_BY, COUNT (*) TOTAL, SUM (TRANS_AMT) AMT\n              FROM AGENT_BANKING.UTILITY_PAYMENT_INFO\n             WHERE     STATUS = 'S'\n                   AND TRUNC (ENTRY_DATE) BETWEEN TRUNC (\n                                                      ADD_MONTHS (\n                                                          TRUNC(\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1),\n                                                      'MM')\n                                              AND LAST_DAY (\n                                                      ADD_MONTHS (\n                                                          TRUNC (\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1))\n          GROUP BY ENTRY_BY) UP\n             ON REG.MPHONE = UP.ENTRY_BY\n         -- Utility Current Month\n         LEFT JOIN\n         (  SELECT ENTRY_BY, COUNT (*) TOTAL, SUM (TRANS_AMT) AMT\n              FROM AGENT_BANKING.UTILITY_PAYMENT_INFO\n             WHERE     STATUS = 'S'\n                   AND TRUNC (ENTRY_DATE) BETWEEN TO_DATE (\n                                                      TRUNC (\n                                                          TO_DATE ( :startingDate,\n                                                                   'DD/MM/RRRR'),\n                                                          'YEAR'),\n                                                      'DD/MM/RRRR')\n                                              AND TO_DATE ( :startingDate, 'DD/MM/RRRR')\n          GROUP BY ENTRY_BY) UC\n             ON REG.MPHONE = UC.ENTRY_BY\n         -- COMMISSION previous Month\n         LEFT JOIN\n         (  SELECT TRANS_TO, ROUND (SUM (PAY_AMT), 2) COMMISSION\n              FROM AGENT_BANKING.GL_TRANS_MST_OLD D\n             WHERE     TRUNC (ENTRY_DATE) BETWEEN TRUNC (\n                                                      ADD_MONTHS (\n                                                          TRUNC (\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1),\n                                                      'MM')\n                                              AND LAST_DAY (\n                                                      ADD_MONTHS (\n                                                          TRUNC (\n                                                              TO_DATE (\n                                                                  :startingDate,\n                                                                  'DD/MM/RRRR'),\n                                                              'MM'),\n                                                          -1))\n                   AND HOTKEY IN ('COMMISSION', 'FLOAT_SHARES')\n          GROUP BY TRANS_TO) PRE_COM\n             ON REG.MPHONE = PRE_COM.TRANS_TO\n         -- COMMISSION Current Month\n         LEFT JOIN\n         (  SELECT TRANS_TO, ROUND (SUM (PAY_AMT), 2) COMMISSION\n              FROM AGENT_BANKING.GL_TRANS_MST_OLD D\n             WHERE     TRUNC (ENTRY_DATE) BETWEEN TO_DATE (\n                                                      TRUNC (\n                                                          TO_DATE ( :startingDate,\n                                                                   'DD/MM/RRRR'),\n                                                          'YEAR'),\n                                                      'DD/MM/RRRR')\n                                              AND TO_DATE ( :startingDate, 'DD/MM/RRRR')\n                   AND HOTKEY IN ('COMMISSION', 'FLOAT_SHARES')\n          GROUP BY TRANS_TO) COM\n             ON     REG.MPHONE = COM.TRANS_TO\n                AND TRUNC (REG.REG_DATE) <= TO_DATE ( :startingDate, 'DD/MM/RRRR')\nORDER BY REG.MPHONE";
                        bindParams = [startingDate.toString()];
                        return [4 /*yield*/, (0, oracleClient_1.default)(sql, bindParams)];
                    case 1:
                        payload = _a.sent();
                        return [2 /*return*/, payload.rows];
                }
            });
        });
    };
    return Report;
}());
exports.default = Report;
